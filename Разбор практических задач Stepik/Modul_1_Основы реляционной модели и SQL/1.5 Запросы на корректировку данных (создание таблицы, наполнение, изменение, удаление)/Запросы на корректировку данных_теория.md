SQL позволяет не только выбирать данные из таблиц базы данных, но и корректировать информацию в них. 
Для этого используются запросы корректировки данных, с помощью которых можно:
- создать пустую таблицу;
- добавить в таблицу записи как совокупность значений;
- добавить записи из другой таблицы;
- добавить записи из другой таблицы, используя вложенный запрос;
- изменить значения в одном столбце;
- изменить значения в нескольких столбцах;
- изменить данные, используя несколько таблиц;
- удалить записи из таблицы;
- создать таблицу на основе данных других таблиц.


На данном уроке будут рассматриваться запросы для реализации типичных для склада действий:
- получение нового товара (добавление, обновление, удаление данных);
- продажа товара (обновление данных);
- формирование заказа на новый товар (создание таблицы).

### Оглавление
1. [Создание пустой таблицы](#Создание-пустой-таблицы)
2. [Добавление записей в таблицу](#Добавление-записей-в-таблицу)
3. [Добавление записей из другой таблицы](#Добавление-записей-из-другой-таблицы)
4. [Добавление записей, вложенные запросы](#Добавление-записей-вложенные-запросы)
5. [Запросы на обновление](#Запросы-на-обновление)
6. [Запросы на обновление нескольких столбцов](#Запросы-на-обновление-нескольких-столбцов)
7. [Запросы на обновление нескольких таблиц](#Запросы-на-обновление-нескольких-таблиц)
8. [Запросы на удаление](#Запросы-на-удаление)
9. [Запросы на создание таблицы](#Запросы-на-создание-таблицы)

## Создание пустой таблицы
Создание таблицы осуществляется с помощью запроса ```CREATE```

Здесь я просто повторю создание таблицы, рассматриваемое в [Модуле 1](https://github.com/Egessihora/SQL_RelationalDB/blob/master/Stepik/Modul_1_Основы%20реляционной%20модели%20и%20SQL/1.1%20Отношение%20(таблица)/Отношение%20(таблица)_Теория.md)

Для создания таблицы используется SQL-запрос. В нём указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет 
каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :

- ключевые слова : ```CREATE TABLE```
- имя создаваемой таблицы;
- открывающая круглая скобка «(»;
- название поля и его описание, которое включает тип поля и другие необязательные характеристики;
запятая;
- название поля и его описание;
...
- закрывающая скобка «)».

**Пример**. Создадим таблицу **genre** следующей структуры:

[![4.png](https://i.postimg.cc/RF16D3vd/4.png)](https://postimg.cc/Q9tdBd9K)

*Запрос:*

```sql
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
```
Созданная таблица создаётся пустой. Чтобы проверить, что таблица создана, можно сделать следующий запрос:

***Общий синтаксис запроса:***

```SQL
DESCRIBE table_name;
```

Запрос для таблицы **genre**:

```SQL
DESCRIBE genre;
```

Ключевое слово ```DESCRIBE``` возвращает основные сведения о метаданных таблицы. 
В результате запроса мы увидим имена столбцов, типы столбцов и комментарии к столбцам, которые мы прописали: 

```
+------------+-------------+------+-----+---------+----------------+
| Field      | Type        | Null | Key | Default | Extra          |
+------------+-------------+------+-----+---------+----------------+
| genre_id   | int         | NO   | PRI | NULL    | auto_increment |
| name_genre | varchar(30) | YES  |     | NULL    |                |
+------------+-------------+------+-----+---------+----------------+
Affected rows: 2
```

***Рекомендации по записи SQL-запроса***

- Ключевые слова: SQL не является регистрозависимым языком (```CREATE``` и ```create``` - одно и тоже ключевое слово). 
- Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.
- Имена таблиц и полей - строчными (маленькими) буквами.
- SQL-запрос можно писать на нескольких строках.
- В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).

[:arrow_up:Оглавление](#Оглавление)
___
## Добавление записей в таблицу
Вначаел снова повторяем то, что было в [Модуле 1](https://stepik.org/lesson/297508/step/9?unit=279268)

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения.

Используется команда ```INSERT```, которая имеет следующий формальный синтаксис:

```sql
INSERT INTO имя_таблицы (список_столбцов) VALUES (значение1, значение2, ... значениеN)
```

**Структура запроса**:

- ключевые слова ```INSERT INTO``` (ключевое слово ```INTO``` можно пропустить);
- имя таблицы, в которую добавляется запись;
- открывающая круглая скобка «(»;
- список полей через запятую, в которые следует занести новые данные;
- закрывающая скобка «)»;
- ключевое слово ```VALUES```;
- открывающая круглая скобка «(»;
- список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
- закрывающая скобка «)».


**Пример.** 

В **таблицу**, состоящую из двух столбцов добавим новую строку, при этом в **поле1** заносится **значение1**,  **в поле2** - **значение2**.

```sql
INSERT INTO таблица(поле1, поле2) 
VALUES (значение1, значение2);
```

В результате выполнения запроса новая запись заносится в конец обновляемой таблицы.


При составлении списка полей и списка значений необходимо учитывать следующее:

1. количество полей и количество значений в списках должны совпадать;
2. должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;
3. типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа ```DECIMAL```, обратная операция - недопустима);
4. новые значения нельзя добавлять в поля, описанные как ```PRIMARY KEY``` ```AUTO_INCREMENT```;
5. рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (```NULL```).

**Пример**

Вставим новую запись в таблицу **genre**, созданную на предыдущем шаге ( в первых двух строках показана структура таблицы, далее - ее содержимое):

| genre_id                     | name_genre   |
|------------------------------|--------------|
|INT PRIMARY KEY AUTO_INCREMENT|VARCHAR(30)   |
|1                             |Роман         |

*Запрос:*

```sql
INSERT INTO genre (name_genre) 
VALUES ('Роман');
```

Заносится только значение поля **name_genre**, значение ключевого поля формируется автоматически.

Чтобы посмотреть результат, отправляем запрос ```SELECT * FROM genre;```

```SQL
+----------+-------------+
| genre_id | name_genre  |
+----------+-------------+
|        1 | Роман       |
+----------+-------------+
```

___
Можно сразу прописывать перед отправкой несколько запросов, разделяя их точкой с запятой!

**Пример**:

```sql
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);

INSERT INTO genre (name_genre) 
VALUES ('Роман');

SELECT * FROM genre;
```
___

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:

```SQL
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```

Например, чтобы добавить в таблицу **book** две новые записи используется запрос:

```SQL
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

[:arrow_up:Оглавление](#Оглавление)
___
## Добавление записей из другой таблицы
С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список ```VALUES```), но и записи из
другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела ```VALUES``` записывается запрос на
выборку, начинающийся с ```SELECT```.  В нем можно использовать ```WHERE```, ```GROUP BY```, ```ORDER BY```.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
- количество полей в таблице и количество полей в запросе должны совпадать;
- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
- типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа ```DECIMAL```, обратная операция – недопустима).

**Пример**

Занести все книги из таблицы **supply** в таблицу **book**.

**Запрос**:

```SQL
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```

**Результат**:

```SQL
Affected rows: 4
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 9
```

С помощью этого запроса в таблицу **book** включены все книги из **supply**, даже те, которые в **book** уже есть («Белая гвардия» и
«Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это
нежелательная ситуация. Устранить эту проблему можно с помощью **вложенных запросов**, которые будут рассмотрены в следующем шаге.

[:arrow_up:Оглавление](#Оглавление)
___
## Добавление записей, вложенные запросы
В запросах на добавление можно использовать **вложенные запросы**.

**Пример**

Занести из таблицы **supply** в таблицу **book** только те книги, названия которых отсутствуют в таблице **book**.

**Запрос:**

```SQL
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
```

**Результат:**

```SQL
Affected rows: 2

Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```

Вложенным запросом отбираются все названия книг, которые есть в таблице **book**. Основным запросом ```SELECT``` из таблицы **supply** выбираются книги, названия которых нет в результате вложенного запроса. Отобранные записи добавляются в конец таблицы **book** запросом на добавление ```INSERT```.

[:arrow_up:Оглавление](#Оглавление)
___
## Запросы на обновление
Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как
изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса ```UPDATE```. Простейший запрос на  обновление выглядит так:

```SQL
UPDATE таблица SET поле = выражение
```

где 
- **таблица** – имя таблицы, в которой будут проводиться изменения;
- **поле** – поле таблицы, в которое будет внесено изменение;
- **выражение** – выражение,  значение которого будет занесено в поле.

___
**Пример**

Уменьшить на 30% цену книг в таблице **book**.

**Запрос:***

```SQL
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```

**Результат:**

```SQL
Affected rows: 5
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово ```WHERE```, после которого указывается условие отбора строк для изменения.

___
**Пример**

Уменьшить на 30% цену тех книг в таблице **book**, количество которых меньше 5.

**Запрос:**

```SQL
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
```

**Результат:**

```SQL
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе обновляется только 2 записи (цена книг «Мастер и Маргарита» и «Братья Карамазовы»).

[:arrow_up:Оглавление](#Оглавление)
___
## Запросы на обновление нескольких столбцов
Запросом ```UPDATE``` можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:

```SQL
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

На складе, кроме хранения и получения книг, выполняется их оптовая продажа. Для реализации этого действия включим дополнительный столбец **buy**  в таблицу **book**:

|book_id                       |	title            |	author	         |price	      |amount|buy|
|------------------------------|---------------------|-------------------|------------|------|---|
|INT PRIMARY KEY AUTO_INCREMENT|	VARCHAR(50)	     |VARCHAR(30)	     |DECIMAL(8,2)|	INT	 |int|
|1	                           |Мастер и Маргарита   |	Булгаков М.А.	 |670.99	  |3	 |0  |
|2	                           |Белая гвардия	     |  Булгаков М.А.	 |540.50	  |5	 |3  |
|3	                           |Идиот                |	Достоевский Ф.М. |460.00	  |10	 |8  |
|4	                           |Братья Карамазовы    |	Достоевский Ф.М. |799.01	  |2	 |0  |
|5	                           |Стихотворения и поэмы|	Есенин С.А.	     |650.00	  |15	 |18 |

**Пример**

В столбце **buy** покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбце **buy** количество, а в столбец **buy** занести 0.

**Запрос**:

```SQL
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```

**Результат:**

```SQL
Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
```

Как видно из таблицы, без проверки данных, которые занесены в столбец,  нельзя запускать запрос на обновление (может получиться отрицательное значение количества).

[:arrow_up:Оглавление](#Оглавление)
___
## Запросы на обновление нескольких таблиц
В запросах на обновление можно использовать несколько таблиц, но тогда
- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, **```book.price```** – столбец **```price```** из таблицы **```book```**, **```supply.price```** – столбец **```price```** из таблицы **```supply```**;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова ```UPDATE```;
- в запросе обязательно условие ```WHERE```, в котором указывается условие при котором обновляются данные.

**Пример**

Если в таблице **supply**  есть те же книги, что и в таблице **book**, добавлять эти книги в таблицу **book** не имеет смысла. Необходимо увеличить их количество на значение столбца **amount** таблицы **supply**.

**Запрос**:

```SQL
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```

**Результат:**

```SQL
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в **supply** имеет ту же цену, и «Идиот», но цена этой книги в таблицах **book** и **supply** отличается. Для этой книги нужно пересчитать цену.

[:arrow_up:Оглавление](#Оглавление)
___
## Запросы на удаление
Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:

```SQL
DELETE FROM таблица;
```

Этот запрос удаляет **все** записи из указанной после ```FROM``` таблицы.

**Пример**

После того, как информация о книгах из таблицы **supply** перенесена в **book** , необходимо очистить таблицу  **supply**.

**Запрос:**

```SQL
DELETE FROM supply;

SELECT * FROM supply;
```

**Результат:**

```SQL
Affected rows: 4
Affected rows: 0
```

Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.

Запросы на удаления позволяют удалить не только все записи таблицы, но и только те, которые удовлетворяют условию, указанному после ключевого слова ```WHERE```:

```SQL
DELETE FROM таблица
WHERE условие;
```

**Пример**

Удалить из таблицы **supply** все книги, названия которых есть в таблице **book**.

**Запрос**:

```SQL
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );


SELECT * FROM supply;
```

**Результат**:

```SQL
Affected rows: 2

Query result:
+-----------+--------------------------+------------------+--------+--------+
| supply_id | title                    | author           | price  | amount |
+-----------+--------------------------+------------------+--------+--------+
| 1         | Лирика                   | Пастернак Б.Л.   | 518.99 | 2      |
| 2         | Черный человек           | Есенин С.А.      | 570.20 | 6      |
+-----------+--------------------------+------------------+--------+--------+
```

Из таблицы **supply** удалены две записи о книгах «Белая гвардия» и «Идиот».

[:arrow_up:Оглавление](#Оглавление)
___
## Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос ```SELECT```, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```SQL
CREATE TABLE имя_таблицы AS
SELECT ...
```

**Пример**

Создать таблицу заказ (**ordering**), куда включить авторов и названия тех книг, количество экземпляров которых в таблице **book** меньше 4. Для всех книг указать одинаковое количество экземпляров 5.

**Запрос:**

```SQL
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

**Результат:**

```SQL
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 5      |
| Достоевский Ф.М. | Братья Карамазовы  | 5      |
+------------------+--------------------+--------+
```

При создании таблицы можно использовать вложенные запросы как после ```SELECT```, так и после ```WHERE```.

**Пример**

Создать таблицу заказ (**ordering**), куда включить авторов и названия тех книг, количество экземпляров которых в таблице **book** меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице **book**.

**Запрос:**

```SQL
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

**Результат:**

```SQL
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
```

[:arrow_up:Оглавление](#Оглавление)
___
