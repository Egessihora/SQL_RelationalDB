### Оглавление:
1. [Соединение INNER JOIN](#Соединение-inner-join)
2. [Внешнее соединение LEFT и RIGHT OUTER JOIN](#Внешнее-соединение-left-и-right-outer-join)
3. [Перекрестное соединение CROSS JOIN](#Перекрестное-соединение-cross-join)
4. [Альтернативная визуализация Джойнов](#Альтернативная-визуализация-джойнов)
5. [Соединение трёх и более таблиц](#Соединение-трёх-и-более-таблиц)

Для объединения данных с нескольких таблиц используются **Join**'ы. Существует несколько форматов объединения данных: **Inner**, **Left**, **Right** и **Outer**. Принцип их работы представлен на фото ниже:

##### Круги Венна
[![image.jpg](https://i.postimg.cc/5ygVsGfv/image.jpg)](https://postimg.cc/hQX6j2zP)


## Соединение INNER JOIN

Оператор внутреннего соединения **INNER JOIN** соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
И используется, когда нам не важно какую таблицу с какой и в каком порядке соединять. Также важно понять, что **INNER JOIN** позволяет взять лишь те данные, которые являются **общими** для соединяемых таблиц (смотрим ещё раз рисунок ⏫).

```SQL
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие соединения
...
```

Результат запроса формируется так:

- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка.

Условие соединения **ON** имеет ограничения:

- в условии поиска должны быть колонки только тех таблиц, которые участвуют в соединении;
- условие соединение не может содержать никаких подзапросов.

**Пример**

Вывести название книг и их авторов.

*Запрос:*

```SQL
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Поскольку поля **author_id** в таблицах **book** и **author** называются одинаково, необходимо в запросах указывать полную ссылку на них 
(**book.author_id** и **author.author_id**).

*Результат:*

| title                 | name_author      |
|-----------------------|------------------|
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |

В данном запросе осуществляется соединение главной таблицы **author** и зависимой таблицы **book** по ключевому
столбцу **author.author_id** и внешнему ключу **book.author_id**. При этом в результирующую таблицу запроса включаются все
строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы **book** дополняются фамилией и
инициалами авторов из таблицы **author**.

[:arrow_up:Оглавление](#Оглавление)

___
## Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения **LEFT OUTER JOIN**  (можно использовать **LEFT JOIN**) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

```SQL
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

в результат включается внутреннее соединение (**INNER JOIN**) первой и второй таблицы в соответствии с условием;
затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение **RIGHT JOIN** действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

**Пример**

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

*Запрос:*

```SQL
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;
```
     
*Результат:*


| name_author      | title                 |
|------------------|-----------------------|
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |

Так как в таблице **book** нет книг Лермонтова, напротив этой фамилии стоит Null.

[:arrow_up:Оглавление](#Оглавление)

____
## Перекрёстное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения **CROSS JOIN** (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

```SQL
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```

или

```SQL
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```

Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:

```SQL
SELECT name_author, name_genre
FROM 
    author, genre;
```

каждому автору из таблицы **author** поставит в соответствие все возможные жанры из таблицы **genre**:

| name_author      | name_genre  |
|------------------|-------------|
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |

[:arrow_up:Оглавление](#Оглавление)

____
## Альтернативная визуализация Джойнов
Очень мне понравилась статья на Habr-е, автор которой очень наглядно и просто описывает Джойны. Я размещу у себя только ключевые моменты, а вы при желании можете просмотреть всю [статью](https://habr.com/ru/articles/450528/) 

Автор статьи обратил внимание, что многие, опираясь на визуализацию соединения через круги Венна на [иллюстрации](#круги-венна) неверно интерпретируют соединения и даже путают понятия. Таблицы называют множествами, а общие данные - пересечениями. Давайте же разберёмся, как всё обстоит на самом деле.

**Join** — это скорее декартово произведение, чем пересечение. Если посмотреть, как иллюстрируют декартово произведение, то можно заметить, что зачастую это прямоугольная таблица, где по одной оси идет первое отношение, а по другой — второе. Таким образом элементы таблицы будут представлять собой **все комбинации всего**.

Допустим, у нас есть две таблицы. В одной из них


```
id
--
1
1
6
5
```

В другой:

```
id
--
1
1
2
3
5
```
*поле названо словом "id" просто для краткости*

Итак, мы хотим узнать, что же получится при различных джойнах таблиц. Начнем с **CROSS JOIN**:

### CROSS JOIN
```SQL
SELECT t1.id, t2.id
FROM t1 
    CROSS JOIN t2
```

CROSS JOIN — это все все возможные комбинации, которые можно получить из двух таблиц.

Визуализировать это можно так: по оси x — одна таблица, по оси y — другая, все клеточки внутри (выделены оранжевым) — это результат

[![cnpm1u8xvea5yn9l2-zs0aslnhi.png](https://i.postimg.cc/WbkDBmZ1/cnpm1u8xvea5yn9l2-zs0aslnhi.png)](https://postimg.cc/9rcFT716)

### INNER JOIN

INNER JOIN (или просто JOIN) — это тот же самый CROSS JOIN, у которого оставлены только те элементы, которые удовлетворяют условию, записанному в конструкции "ON". Обратите внимание на ситуацию, когда записи дублируются — результатов с единичками будет четыре штуки.

```SQL
SELECT t1.id, t2.id
FROM t1 
    INNER JOIN t2
        ON t1.id = t2.id
```

[![zytr9aow8-2bopcicmymuhxdjj4.png](https://i.postimg.cc/tghwwcqN/zytr9aow8-2bopcicmymuhxdjj4.png)](https://postimg.cc/gw2g6N6x)

По сути INNER JOIN — это все комбинации соединений строк с неким фильтром condition.

Две конструкции на иллюстрации - идентичны

[![2023-08-06-21-56-03.png](https://i.postimg.cc/gkvH8LDr/2023-08-06-21-56-03.png)](https://postimg.cc/gn2hPJ1P)

Хотя inner join логически эквивалентен cross join с фильтром, это не значит, что база будет делать именно так, в тупую: генерить все комбинации и фильтровать. На самом деле там более интересные алгоритмы.

### LEFT JOIN
LEFT OUTER JOIN (или просто LEFT JOIN) — это тоже самое, что и INNER JOIN, но дополнительно мы добавляем null для строк из первой таблицы, для которой ничего не нашлось во второй

```SQL
SELECT t1.id, t2.id
FROM t1
    LEFT JOIN t2
        ON t1.id = t2.id
```

[![d7cb7cq3l98dtscuzpwoh-njiro.png](https://i.postimg.cc/13RKsYrK/d7cb7cq3l98dtscuzpwoh-njiro.png)](https://postimg.cc/nC5m125s)

### RIGHT JOIN

RIGHT OUTER JOIN ( или RIGHT JOIN) — это тоже самое, что и LEFT JOIN, только наоборот. Т.е. это INNER JOIN + null для строк из второй таблицы, для которой ничего не нашлось в первой

```SQL
SELECT t1.id, t2.id
FROM t1
    RIGHT JOIN t2
        ON t1.id = t2.id
```

[![dv4fmfmfwy97ki2d9ui-wnabmwi.png](https://i.postimg.cc/fy362RJJ/dv4fmfmfwy97ki2d9ui-wnabmwi.png)](https://postimg.cc/xN2xqYG2)

____
*В [этом видео](https://youtu.be/e4PUGpZlcIw) автор статьи наглядно объясняет, как правильно визуализировать джойны (только на English)*

[:arrow_up:Оглавление](#Оглавление)

____
## Соединение трёх и более таблиц
Запрос на выборку может выбирать данные из двух (как мы раньше рассмотрели), а также изтрёх и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для **каждой пары** таблиц, включаемых в запрос, необходимо указать **свой оператор соединения**. Наиболее распространенным является внутреннее соединение **INNER JOIN**, поэтому в примерах будем использовать его.

**Общий синтаксис запроса SQL, чтобы присоединить три или более таблиц**:

```SQL
SELECT t1.col, t3.col 
FROM table1
     join table2 ON table1.primarykey = table2.foreignkey
     join table3 ON table2.primarykey = table3.foreignkey
```
*Технически вместо primarykey и foreignkey могут быть любые другие общие столбцы, но в практике обычно индексы строят по тем колонкам, через которые построена связь между таблицами. Тогда JOINs работают максимально эффективно при выборке данных.*

Мы сначала присоединим таблицу 2 к таблице 1, которые создадут временную таблицу с комбинированными данными из table1 и table2, а затем присоединим к Table3. Эта формула может быть распространена на более, чем 3-х таблиц в N таблиц. Вам просто нужно убедиться, что SQL — запрос должен иметь N-1 join, чтобы присоединить N таблиц. Как для объединения двух таблиц мы требуем 1 join, а для присоединения 3-х таблиц нам нужно 2 join.

Пусть таблицы связаны между собой следующим образом:

[![cx2.jpg](https://i.postimg.cc/kg6Vkrkt/cx2.jpg)](https://postimg.cc/jDTd71qs)

тогда запрос на выборку для этих таблиц будет иметь вид:

```SQL
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```

Здесь мы объединяем три таблицы: **first**, **second** и **third**

Мы выбираем определенные столбцы из каждой таблицы, а затем используем оператор **JOIN** для объединения таблиц **first** и **second**, а затем таблиц **second** и **third**.

Обратите внимание, что для успешного объединения таблиц необходимо **наличие общих столбцов** в этих таблицах. Кроме того, если таблицы содержат дублирующиеся строки, то результатом объединения могут быть дублирующиеся строки. Чтобы исключить дубли, можно использовать оператор **DISTINCT**.
___
Пример из статьи с сайта [andreyex.ru](https://andreyex.ru/bazy-dannyx/uchebnoe-posobie-po-sql/kak-prisoedinitsya-tri-tablicy-v-sql-zaprose-mysql-primer/) с моими исправлениями:

Для того, чтобы лучше понять присоединение 3-й таблицы в SQL запросе, давайте рассмотрим популярный пример **Employee** и **Department**. В нашем случае мы используем таблицу ссылок под названием **Register**, которая связывает или создаёт отношение **Employee** для **Department**. Первичный ключ таблицы **Employee** (emp_id) является внешним ключом в **Register** и аналогичным образом, первичный ключ таблицы **Department** (dept_id) является внешним ключом в таблице **Register**.

*к сожалению, схема таблиц отсутствует*

Для того , чтобы написать запрос SQL для печати **имя сотрудника** и **название отдела** мы должны присоединиться к трём таблицам. 

Первое присоединение **Employee** и **Register** и создают временную таблицу, с колонкой **dept_id**. 

Теперь второе присоединение таблицы **Department** к этой временной таблице по колонке **dept_id**, чтобы получить желаемый результат. 

Вот полный SELECT, пример SQL — запроса, чтобы присоединиться к 3-м таблицам, и она может быть расширена, чтобы присоединиться к более, чем 3 или N таблицам:

```SQL
mysql> SELECT * FROM Employee;
+--------+----------+--------+
| emp_id | emp_name | salary |
+--------+----------+--------+
| 1      | Антон    |   1900 |
| 2      | Макс     |   3800 |
| 3      | Артем    |   5500 |
| 4      | Дмитрий  |   7600 |
+--------+----------+--------+
4 rows IN SET (0.00 sec)

mysql> SELECT * FROM Department;
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
| 101     | Sales     |
| 102     | Marketing |
| 103     | Finance   |
+---------+-----------+
3 rows IN SET (0.00 sec)

mysql> SELECT * FROM Register;
+--------+---------+
| emp_id | dept_id |
+--------+---------+
|      1 |     101 |
|      2 |     102 |
|      3 |     103 |
|      4 |     102 |
+--------+---------+
4 rows IN SET (0.00 sec)

mysql> SELECT emp_name, dept_name FROM Employee e 
JOIN Register r ON e.emp_id=r.emp_id 
JOIN Department d ON r.dept_id=d.dept_id;
+----------+-----------+
| emp_name | dept_name |
+----------+-----------+
| Антон    | Sales     |
| Макс     | Marketing |
| Артем    | Finance   |
| Дмитрий  | Marketing |
+----------+-----------+
4 rows IN SET (0.01 sec)
```

Если вы хотите понять это лучше, попытайтесь объединить таблицы шаг за шагом. Таким образом, вместо того, чтобы присоединить 3 таблицы за один раз, сначала соедините 2 таблицы и посмотрите, как будет выглядеть таблица результатов. 

[:arrow_up:Оглавление](#Оглавление)

____
