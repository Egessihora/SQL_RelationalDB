### Оглавление:
1. [Соединение INNER JOIN](#Соединение-inner-join)
2. [Внешнее соединение LEFT и RIGHT OUTER JOIN](#Внешнее-соединение-left-и-right-outer-join)
3. [Перекрестное соединение CROSS JOIN](#Перекрестное-соединение-cross-join)
4. [Альтернативная визуализация Джойнов](#Альтернативная-визуализация-джойнов)

Для объединения данных с нескольких таблиц используются **Join**'ы. Существует несколько форматов объединения данных: **Inner**, **Left**, **Right** и **Outer**. Принцип их работы представлен на фото ниже:

[![image.jpg](https://i.postimg.cc/5ygVsGfv/image.jpg)](https://postimg.cc/hQX6j2zP)

Круги Венна

## Соединение INNER JOIN

Оператор внутреннего соединения **INNER JOIN** соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
И используется, когда нам не важно какую таблицу с какой и в каком порядке соединять. Также важно понять, что **INNER JOIN** позволяет взять лишь те данные, которые являются **общими** для соединяемых таблиц (смотрим ещё раз рисунок ⏫).

```SQL
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие соединения
...
```

Результат запроса формируется так:

- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка.

Условие соединения **ON** имеет ограничения:

- в условии поиска должны быть колонки только тех таблиц, которые участвуют в соединении;
- условие соединение не может содержать никаких подзапросов.

**Пример**

Вывести название книг и их авторов.

*Запрос:*

```SQL
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Поскольку поля **author_id** в таблицах **book** и **author** называются одинаково, необходимо в запросах указывать полную ссылку на них 
(**book.author_id** и **author.author_id**).

*Результат:*

| title                 | name_author      |
|-----------------------|------------------|
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |

В данном запросе осуществляется соединение главной таблицы **author** и зависимой таблицы **book** по ключевому
столбцу **author.author_id** и внешнему ключу **book.author_id**. При этом в результирующую таблицу запроса включаются все
строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы **book** дополняются фамилией и
инициалами авторов из таблицы **author**.

[:arrow_up:Оглавление](#Оглавление)

___
## Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения **LEFT OUTER JOIN**  (можно использовать **LEFT JOIN**) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

```SQL
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

в результат включается внутреннее соединение (**INNER JOIN**) первой и второй таблицы в соответствии с условием;
затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение **RIGHT JOIN** действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

**Пример**

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

*Запрос:*

```SQL
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;
```
     
*Результат:*


| name_author      | title                 |
|------------------|-----------------------|
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |

Так как в таблице **book** нет книг Лермонтова, напротив этой фамилии стоит Null.

[:arrow_up:Оглавление](#Оглавление)

____
## Перекрёстное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения **CROSS JOIN** (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

```SQL
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```

или

```SQL
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```

Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:

```SQL
SELECT name_author, name_genre
FROM 
    author, genre;
```

каждому автору из таблицы **author** поставит в соответствие все возможные жанры из таблицы **genre**:

| name_author      | name_genre  |
|------------------|-------------|
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |

[:arrow_up:Оглавление](#Оглавление)

____
## Альтернативная визуализация Джойнов
Очень мне понравилась статья на Habr-е, автор которой очень наглядно и просто описывает Джойны. Я размещу у себя только ключевые моменты, а вы при желании можете просмотреть всю [статью](https://habr.com/ru/articles/450528/) 

Автор статьи обратил внимание, что многие, опираясь на визуализацию соединения через круги Венна на [иллюстрации](#Круги-венна) неверно интерпретируют соединения и даже путают понятия. Таблицы называют множествами, а общие данные - пересечениями. Давайте же разберёмся, как всё обстоит на самом деле.

**Join** — это скорее декартово произведение, чем пересечение. Если посмотреть, как иллюстрируют декартово произведение, то можно заметить, что зачастую это прямоугольная таблица, где по одной оси идет первое отношение, а по другой — второе. Таким образом элементы таблицы будут представлять собой **все комбинации всего**.

Допустим, у нас есть две таблицы. В одной из них


```
id
--
1
1
6
5
```

В другой:

```
id
--
1
1
2
3
5
```
*поле названо словом "id" просто для краткости*

Итак, мы хотим узнать, что же получится при различных джойнах таблиц. Начнем с **CROSS JOIN**:

### CROSS JOIN
```SQL
SELECT t1.id, t2.id
FROM t1 
    CROSS JOIN t2
```

CROSS JOIN — это все все возможные комбинации, которые можно получить из двух таблиц.

Визуализировать это можно так: по оси x — одна таблица, по оси y — другая, все клеточки внутри (выделены оранжевым) — это результат

[![cnpm1u8xvea5yn9l2-zs0aslnhi.png](https://i.postimg.cc/WbkDBmZ1/cnpm1u8xvea5yn9l2-zs0aslnhi.png)](https://postimg.cc/9rcFT716)

### INNER JOIN

INNER JOIN (или просто JOIN) — это тот же самый CROSS JOIN, у которого оставлены только те элементы, которые удовлетворяют условию, записанному в конструкции "ON". Обратите внимание на ситуацию, когда записи дублируются — результатов с единичками будет четыре штуки.

```SQL
SELECT t1.id, t2.id
FROM t1 
    INNER JOIN t2
        ON t1.id = t2.id
```

[![zytr9aow8-2bopcicmymuhxdjj4.png](https://i.postimg.cc/tghwwcqN/zytr9aow8-2bopcicmymuhxdjj4.png)](https://postimg.cc/gw2g6N6x)

По сути INNER JOIN — это все комбинации соединений строк с неким фильтром condition.

Две конструкции на иллюстрации - идентичны

[![2023-08-06-21-56-03.png](https://i.postimg.cc/gkvH8LDr/2023-08-06-21-56-03.png)](https://postimg.cc/gn2hPJ1P)

Хотя inner join логически эквивалентен cross join с фильтром, это не значит, что база будет делать именно так, в тупую: генерить все комбинации и фильтровать. На самом деле там более интересные алгоритмы.

### LEFT JOIN
LEFT OUTER JOIN (или просто LEFT JOIN) — это тоже самое, что и INNER JOIN, но дополнительно мы добавляем null для строк из первой таблицы, для которой ничего не нашлось во второй

```SQL
SELECT t1.id, t2.id
FROM t1
    LEFT JOIN t2
        ON t1.id = t2.id
```

[![d7cb7cq3l98dtscuzpwoh-njiro.png](https://i.postimg.cc/13RKsYrK/d7cb7cq3l98dtscuzpwoh-njiro.png)](https://postimg.cc/nC5m125s)

### RIGHT JOIN

RIGHT OUTER JOIN ( или RIGHT JOIN) — это тоже самое, что и LEFT JOIN, только наоборот. Т.е. это INNER JOIN + null для строк из второй таблицы, для которой ничего не нашлось в первой

```SQL
SELECT t1.id, t2.id
FROM t1
    RIGHT JOIN t2
        ON t1.id = t2.id
```

[![dv4fmfmfwy97ki2d9ui-wnabmwi.png](https://i.postimg.cc/fy362RJJ/dv4fmfmfwy97ki2d9ui-wnabmwi.png)](https://postimg.cc/xN2xqYG2)

____
*В [этом видео](https://youtu.be/e4PUGpZlcIw) автор статьи наглядно объясняет, как правильно визуализировать джойны (только на English)*

[:arrow_up:Оглавление](#Оглавление)

____
