## TASK 1.3.6 [задание на stepik](https://stepik.org/lesson/297515/step/8?unit=279275)
Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех
авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец
назвать Стоимость. Результат отсортировать по убыванию стоимости.

**Решение:**

```SQL
SELECT 
    author,
    SUM(price * amount) AS Стоимость
FROM book
WHERE title <> 'Идиот' AND title <> 'Белая гвардия'
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY Стоимость DESC;
```

**Перевод на человеческий:**

```SQL
/*выбери
   столбец author
   столбцы price и amount, перемножь значения этих столбцов, вычисли сумму полученного результата умножения построчно,
назови новый результирующий столбец как Стоимость*/
/*из таблицы book*/
/*выбери только те строки, которые не содержат названия книг в столбце title "Идиот" и "Белая гвардия"*/
/*сгруппируй по столбцу author*/
/*перемножь значения столбцов price и amount, вычисли сумму полученного результата, и выбери только те строки, в которых
значение полученного результата суммирования больше 5000*/
/*отсортируй по столбцу Стоимость в порядке убывания*/
```

**Результат**

```SQL
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Есенин С.А.      | 9750.00   |
| Достоевский Ф.М. | 7202.03   |
+------------------+-----------+
Affected rows: 2
```

**Пояснения**:
Пояснения по этому заданию я лучше расскажу не в порядке на писания запроса (как в комментариях к коду), а в том порядке, в каком запрос будет выполнять SQL
сервер. Думаю, так будет понятнее логика действий.

- пишем, что надо сделать запрос из таблицы **book** с помощью оператора ```FROM```

```SQL
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

- после этого в первую очередь (как я понимаю - для исключения обработки ненужных строк) с помощью оператора ```WHERE``` мы выбираем только те строки,
которые не содержат названия книг в столбце **title** "Идиот" и "Белая гвардия", используем оператор сравнения  ```<>``` означающий **неравенство**
и логический оператор ```AND```, который указывает на то, что для выборки должны быть выполнены все условия по его обе стороны

В результате остаётся 4 строки:

```SQL
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

- далее из оставшихся после предыдущего отбора строк происходит их группировка с помощью оператора ```GROUP BY``` по столбцу **author**, в результате чего
авторы по их ФИО формируются в 3 группы: Булгаков М.А., Достоевский Ф.М. и Есенин С.А.

- теперь будем работать с данными по каждой группе: нам нужно перемножить значения столбцов **price** и **amount**, вычислить сумму
полученного результата умножения с помощью оператора ```SUM``` и выбрать с помощью оператора ```HAVING``` только те строки, в которых значение
полученного результата суммирования больше 5000.

Получаем:

```SQL
+------------------+---------------------+
| author           | SUM(price * amount) |
+------------------+---------------------+
| Достоевский Ф.М. | 7202.03             |
| Есенин С.А.      | 9750.00             |
+------------------+---------------------+
```

На данном этапе мы не можем ещё для результирующего столбца использовать псевдоним **Стоимость**, поэтому пишем пока так, как есть с именами существующих
столбцов.

- и только сейчас мы будем использовать оператор ```SELECT``` для формирования данных результирующей выборки и присваивания новым столбцам псевдонимов:
   - сначала нам нужен столбец **author** как есть без всякой обработки
   - и еще нужен столбец, в котором мы снова высчитываем суммарную стоимость книг SUM(price * amount) но уже по 2-м оставшимся строкам
  и теперь можем присвоить результирующему столбцу новое имя (псевдоним) "Стоимость" с помощью оператора присвоения ```AS```

```SQL
+------------------+---------------------+
| author           | Стоимость           |
+------------------+---------------------+
| Достоевский Ф.М. | 7202.03             |
| Есенин С.А.      | 9750.00             |
+------------------+---------------------+
```
- осталось наши данные в результирущей табличке отсортировать с помощью оператора ```ORDER BY``` в порядке убывания, для этого используем ключевое слово
```DESC```

```SQL
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Есенин С.А.      | 9750.00   |
| Достоевский Ф.М. | 7202.03   |
+------------------+-----------+
Affected rows: 2
```

В данном задании можно увидеть, как в одном запросе могут сосуществовать операторы ```WHERE``` и ```HAVING```. Главное понимать в каком порядке что
выполняет SQL сервером и когда мы должны использовать ```WHERE```, а когда ```HAVING```.

Продублирую здесь напоминалку о порядке выполнения запроса:

|Порядок выполнения|Оператор              |Действие                                                                                                       |
|------------------|----------------------|---------------------------------------------------------------------------------------------------------------|
|1                 |FROM                  |Сначала определяется таблица, из которой выбираются данные (```FROM```)                                        |
|2                 |WHERE                 |Затем из этой таблицы отбираются записи в соответствии с условием ```WHERE```                                  |
|3                 |GROUP BY              |Выбранные данные агрегируются (```GROUP BY```)                                                                 |
|4                 |HAVING                |Из агрегированных записей выбираются те, которые удовлетворяют условию после ```HAVING```                      |
|5                 |SELECT                |Потом формируются данные результирующей выборки, как это указано после ```SELECT``` ( вычисляются выражения, присваиваются имена и пр.)                                                                                                                                |
|6                 |ORDER BY              |Результирующая выборка сортируется, как указано после ```ORDER BY```                                           |


Информация по поводу использования ```WHERE``` и ```HAVING``` из [документации](https://postgrespro.ru/docs/postgrespro/11/tutorial-agg)
>Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции
>(таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.
>Как следствие, предложение WHERE не должно содержать агрегатных функций.
>Не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций.
>Предложение HAVING, напротив, всегда содержит агрегатные функции. (Строго говоря, вы можете написать предложение HAVING, не используя агрегаты,
>но это редко бывает полезно. То же самое условие может работать более эффективно на стадии WHERE.)
