SQL запросы позволяют производить вычисления не только для каждой строки таблицы, но и для группы элементов, расположенных в одном столбце. 

Для этого используются групповые (агрегатные) функции. 

Все запросы в этом уроке будут формулироваться для таблицы **book**. Создание, заполнение:

```SQL
DROP TABLE IF EXISTS book;

CREATE TABLE book
(
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title   VARCHAR(50),
    author  VARCHAR(30),
    price   DECIMAL(8, 2),
    amount  INT
);

INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3),
       ('Белая гвардия', 'Булгаков М.А.', 540.50, 5),
       ('Идиот', 'Достоевский Ф.М.', 460.00, 10),
       ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 3),
       ('Игрок', 'Достоевский Ф.М.', 480.50, 10),
       ('Стихотворения и поэмы', 'Есенин С.А.', 650.00, 15);

SELECT * FROM book;
```

### Оглавление
1. [Выбор уникальных элементов столбца](#Выбор-уникальных-элементов-столбца)
2. [Выборка данных, групповые функции SUM и COUNT](#Выборка-данных-групповые-функции-sum-и-count)
3. [Выборка данных, групповые функции MIN, MAX и AVG](#Выборка-данных-групповые-функции-MIN-MAX-и-AVG)
4. [Выборка данных c вычислением, групповые функции](#Выборка-данных-c-вычислением-групповые-функции)
5. [Вычисления по таблице целиком](#Вычисления-по-таблице-целиком)
6. [Выборка данных по условию, групповые функции](#Выборка-данных-по-условию-групповые-функции)
7. [Выборка данных по условию, групповые функции, WHERE и HAVING](#Выборка-данных-по-условию-групповые-функции-where-и-having)

## Выбор уникальных элементов столбца
Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово ```DISTINCT```, которое размещается сразу после ```SELECT```.

*Пример*

Выбрать различных авторов, книги которых хранятся в таблице **book**.

*Запрос*:

```SQL
SELECT DISTINCT author
FROM book;
```

*Результат*:

```SQL
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

Другой способ – использование оператора ```GROUP BY```, который группирует данные при выборке, имеющие одинаковые значения в
некотором столбце. Столбец, по которому осуществляется группировка, указывается после ```GROUP BY```.

С помощью **```GROUP BY```** можно выбрать уникальные элементы столбца, по которому осуществляется группировка. 
Результат будет точно такой же как при использовании ```DISTINCT```.

*Запрос*:

```SQL
SELECT  author
FROM book
GROUP BY author;
```

Оператор **```GROUP BY```** служит для распределения строк - результата запроса - по группам, в которых значения некоторого столбца, 
по которому происходит группировка, являются **одинаковыми**. Группировку можно производить как по одному столбцу, так и по нескольким.

Часто оператор ```GROUP BY``` применяется вместе с агрегатными функциями (```COUNT```, ```SUM```, ```AVG```, ```MAX```, ```MIN```). 

В этих случаях агрегатные функции служат для вычисления соответствующего агрегатного значения ко всему набору строк, для которых некоторый столбец - общий.

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных, групповые функции SUM и COUNT
При группировке над элементами столбца, входящими в группу можно выполнить различные действия, 
например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```SQL
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице **book** определяются строки, в которых в столбце **author** одинаковые значения:

[![t1.png](https://i.postimg.cc/9069tQxv/t1.png)](https://postimg.cc/BPCtJ4fg)

Получили 3 различные группы:

- **группа I** объединяет две записи, у которых в столбце **author** значение Булгаков М.А.;
- **группа II** объединяет три записи, у которых в столбце **author** значение Достоевский Ф.М.;
- **группа III** объединяет одну запись, у которой в столбце **author** значение Есенин С.А.

2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца,
по которому осуществляется группировка (в нашем случае это **author**):

[![t2.png](https://i.postimg.cc/MHHJwyS8/t2.png)](https://postimg.cc/G8W5JTtM)

3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество
экземпляров книг каждого автора. Для этого используется групповая функция ```SUM()```, а в скобках указывается столбец, по которому
нужно выполнить суммирование ( в нашем случае **amount**):

[![t3.png](https://i.postimg.cc/Gp7YMCqh/t3.png)](https://postimg.cc/v1ncBCJp)

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция ```COUNT()```, в скобках можно указать
ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает
```COUNT()```, если в группе есть пустые значения):

[![t4.png](https://i.postimg.cc/13ZwYMS2/t4.png)](https://postimg.cc/Yhbvv6hz)

___
**Пример**

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

*Запрос*:

```SQL
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

*Примечание:*

Обратите внимание, что в качестве названия вычисляемого столбца в результирующей таблице используется выражение. 
Рекомендуется всем  вычисляемым столбцам давать имя.

___
**Пример**

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу **book** добавлена запись с пустыми значениями в столбцах **amount** и **price**:

```SQL
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 7       | Черный человек        | Есенин С.А.      | Null   | Null   |
+---------+-----------------------+------------------+--------+--------+
```

*Запрос*:

```SQL
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+---------------+---------------+----------+
| author           | COUNT(author) | COUNT(amount) | COUNT(*) |
+------------------+---------------+---------------+----------+
| Булгаков М.А.    | 2             | 2             | 2        |
| Достоевский Ф.М. | 3             | 3             | 3        |
| Есенин С.А.      | 2             | 1             | 2        |
+------------------+---------------+---------------+----------+
```

Из таблицы с результатами запроса видно, что функцию ```COUNT()``` можно применять к любому столбцу, в том числе можно
использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения ```Null```, (для группы по автору Есенин в нашем примере), то
- **```COUNT(*)```** —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением ```NULL```;
- **```COUNT(имя_столбца)```** — возвращает количество записей конкретного столбца (только ```NOT NULL```), относящихся к группе.

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных, групповые функции MIN, MAX и AVG
К групповым функциям SQL относятся: ```MIN()```, ```MAX()``` и ```AVG()```, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

**Пример**

Вывести **минимальную** цену книги каждого автора

*Запрос*:

```SQL
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных c вычислением, групповые функции
В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

**Пример**

Вывести **суммарную** стоимость книг каждого автора.

*Запрос*:

```SQL
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
```

Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на
предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

**Пример**

Найти **среднюю** цену книг каждого автора.

*Запрос*:

```SQL
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+--------------+
| author           | Средняя_цена |
+------------------+--------------+
| Булгаков М.А.    | 605.75       |
| Достоевский Ф.М. | 579.84       |
| Есенин С.А.      | 650.00       |
+------------------+--------------+
```

[:arrow_up:Оглавление](#Оглавление)

___
## Вычисления по таблице целиком
Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг
на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова ```SELECT``` указывается групповая функция
для выражения или имени столбца, а ключевые слова ```GROUP BY``` опускаются.

**Пример**

Посчитать количество экземпляров книг на складе.

*Запрос*:

```SQL
SELECT SUM(amount) AS Количество
FROM book;
```

*Результат*:

```SQL
+------------+
| Количество |
+------------+
| 46         |
+------------+
```
 
Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

**Пример**

Посчитать общее количество экземпляров книг на складе и их стоимость .

*Запрос*:

```SQL
SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
```

*Результат*:

```SQL
+------------+-----------+
| Количество | Стоимость |
+------------+-----------+
| 46         | 26267.50  |
+------------+-----------+
```

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных по условию, групповые функции
В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после ```WHERE```. В запросах с групповыми функциями вместо ```WHERE``` используется ключевое слово **```HAVING```** , которое размещается после оператора ```GROUP BY```.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

*Запрос*:

```SQL
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000;
```

*Результат*:

```SQL
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```

Также в запросах с группировкой можно сортировать данные.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

*Запрос*:

```SQL
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

*Результат*:

```SQL
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

*Пояснение*:

При указании столбца, по которому выполняется сортировка, если столбцу присвоено имя  с помощью ```AS```, можно использовать это имя.

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных по условию, групповые функции, WHERE и HAVING
```WHERE``` и ```HAVING``` могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:

|Порядок выполнения|Оператор              |Действие                                                                                                       |
|------------------|----------------------|---------------------------------------------------------------------------------------------------------------|
|1                 |FROM                  |Сначала определяется таблица, из которой выбираются данные (```FROM```)                                        |
|2                 |WHERE                 |Затем из этой таблицы отбираются записи в соответствии с условием ```WHERE```                                  |
|3                 |GROUP BY              |Выбранные данные агрегируются (```GROUP BY```)                                                                 |
|4                 |HAVING                |Из агрегированных записей выбираются те, которые удовлетворяют условию после ```HAVING```                      |
|5                 |SELECT                |Потом формируются данные результирующей выборки, как это указано после ```SELECT``` ( вычисляются выражения, присваиваются имена и пр.)                                                                                                                                |
|6                 |ORDER BY              |Результирующая выборка сортируется, как указано после ```ORDER BY```                                           |

**Важно!** Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку.

Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в ```WHERE``` нельзя использовать имена выражений из ```SELECT```. Просто ```SELECT``` выполняется компилятором позже, чем ```WHERE```, поэтому ему неизвестно, какое там выражение написано.

**Пример**

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 

```SQL
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

*Результат*:

```SQL
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

Другим способом решения примера является запрос:

```SQL
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```

Не смотря на то что результат будет одинаковым, так делать не рекомендуется. Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает.

[:arrow_up:Оглавление](#Оглавление)

___
