SQL запросы позволяют производить вычисления не только для каждой строки таблицы, но и для группы элементов, расположенных в одном столбце. 

Для этого используются групповые (агрегатные) функции. 

Все запросы в этом уроке будут формулироваться для таблицы **book**. Создание, заполнение:

```SQL
DROP TABLE IF EXISTS book;

CREATE TABLE book
(
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title   VARCHAR(50),
    author  VARCHAR(30),
    price   DECIMAL(8, 2),
    amount  INT
);

INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3),
       ('Белая гвардия', 'Булгаков М.А.', 540.50, 5),
       ('Идиот', 'Достоевский Ф.М.', 460.00, 10),
       ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 3),
       ('Игрок', 'Достоевский Ф.М.', 480.50, 10),
       ('Стихотворения и поэмы', 'Есенин С.А.', 650.00, 15);

SELECT * FROM book;
```

### Оглавление
1. [Выбор уникальных элементов столбца](#Выбор-уникальных-элементов-столбца)
2. [Выборка данных, групповые функции SUM и COUNT](#Выборка-данных-групповые-функции-sum-и-count)
3. [Выборка данных, групповые функции MIN, MAX и AVG](#Выборка-данных-групповые-функции-min-max-и-avg)
4. [Выборка данных c вычислением, групповые функции](#Выборка-данных-c-вычислением-групповые-функции)
5. [Вычисления по таблице целиком](#Вычисления-по-таблице-целиком)
6. [Выборка данных по условию, групповые функции](#Выборка-данных-по-условию-групповые-функции)
7. [Выборка данных по условию, групповые функции, WHERE и HAVING](#Выборка-данных-по-условию-групповые-функции-where-и-having)

## Выбор уникальных элементов столбца
Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово ```DISTINCT```, которое размещается сразу после ```SELECT```.

*Пример*

Выбрать различных авторов, книги которых хранятся в таблице **book**.

*Запрос*:

```SQL
SELECT DISTINCT author
FROM book;
```

*Результат*:

```SQL
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

Другой способ – использование оператора ```GROUP BY```, который группирует данные при выборке, имеющие одинаковые значения в
некотором столбце. Столбец, по которому осуществляется группировка, указывается после ```GROUP BY```.

С помощью **```GROUP BY```** можно выбрать уникальные элементы столбца, по которому осуществляется группировка. 
Результат будет точно такой же как при использовании ```DISTINCT```.

*Запрос*:

```SQL
SELECT  author
FROM book
GROUP BY author;
```

Оператор **```GROUP BY```** служит для распределения строк - результата запроса - по группам, в которых значения некоторого столбца, 
по которому происходит группировка, являются **одинаковыми**. Группировку можно производить как по одному столбцу, так и по нескольким.

Часто оператор ```GROUP BY``` применяется вместе с агрегатными функциями (```COUNT```, ```SUM```, ```AVG```, ```MAX```, ```MIN```). 

В этих случаях агрегатные функции служат для вычисления соответствующего агрегатного значения ко всему набору строк, для которых некоторый столбец - общий.

[:arrow_up:Оглавление](#Оглавление)

___
## Выборка данных, групповые функции SUM и COUNT
При группировке над элементами столбца, входящими в группу можно выполнить различные действия, 
например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```SQL
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице **book** определяются строки, в которых в столбце **author** одинаковые значения:

[![t1.png](https://i.postimg.cc/9069tQxv/t1.png)](https://postimg.cc/BPCtJ4fg)

Получили 3 различные группы:

- **группа I** объединяет две записи, у которых в столбце **author** значение Булгаков М.А.;
- **группа II** объединяет три записи, у которых в столбце **author** значение Достоевский Ф.М.;
- **группа III** объединяет одну запись, у которой в столбце **author** значение Есенин С.А.

2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца,
по которому осуществляется группировка (в нашем случае это **author**):

[![t2.png](https://i.postimg.cc/MHHJwyS8/t2.png)](https://postimg.cc/G8W5JTtM)

3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество
экземпляров книг каждого автора. Для этого используется групповая функция ```SUM()```, а в скобках указывается столбец, по которому
нужно выполнить суммирование ( в нашем случае **amount**):

[![t3.png](https://i.postimg.cc/Gp7YMCqh/t3.png)](https://postimg.cc/v1ncBCJp)

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция ```COUNT()```, в скобках можно указать
ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает
```COUNT()```, если в группе есть пустые значения):

[![t4.png](https://i.postimg.cc/13ZwYMS2/t4.png)](https://postimg.cc/Yhbvv6hz)

___
**Пример**

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

*Запрос*:

```SQL
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

*Примечание:*

Обратите внимание, что в качестве названия вычисляемого столбца в результирующей таблице используется выражение. 
Рекомендуется всем  вычисляемым столбцам давать имя.

___
**Пример**

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу **book** добавлена запись с пустыми значениями в столбцах **amount** и **price**:

```SQL
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 7       | Черный человек        | Есенин С.А.      | Null   | Null   |
+---------+-----------------------+------------------+--------+--------+
```

*Запрос*:

```SQL
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```

*Результат*:

```SQL
+------------------+---------------+---------------+----------+
| author           | COUNT(author) | COUNT(amount) | COUNT(*) |
+------------------+---------------+---------------+----------+
| Булгаков М.А.    | 2             | 2             | 2        |
| Достоевский Ф.М. | 3             | 3             | 3        |
| Есенин С.А.      | 2             | 1             | 2        |
+------------------+---------------+---------------+----------+
```

Из таблицы с результатами запроса видно, что функцию ```COUNT()``` можно применять к любому столбцу, в том числе можно
использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения ```Null```, (для группы по автору Есенин в нашем примере), то
- **```COUNT(*)```** —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением ```NULL```;
- **```COUNT(имя_столбца)```** — возвращает количество записей конкретного столбца (только ```NOT NULL```), относящихся к группе.

[:arrow_up:Оглавление](#Оглавление)

___
